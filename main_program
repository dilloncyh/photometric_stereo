import os, glob
import numpy as np
import scipy.linalg as spl
import matplotlib.pylab as plt
import cv2
import time

shadow_map = np.zeros(shape=(500*500,8))

def load_files(path,extension,colour=False):
    if colour == True:
        colour_setting = 1
    else:
        colour_setting = 0
    os.chdir(path)
    file_name_list =  glob.glob(extension)
    image_list = []
    name_list = []      #for dubugging only
    
    for i in range(len(file_name_list)):
        image_list.append(cv2.imread(file_name_list[i], colour_setting))
        name_list.append(file_name_list[i])      #for debugging only
    #print name_list
    return np.array(image_list)#, name_list
    
def ball_shape(img, min_radius=30, max_radius=50):
    N = img.shape[0]
    circles = np.empty(shape=(N,3))  
    
    #check to see if the image is already in grayscale, and converts it if it is not
    for i in range(N):
        if img[i].shape[-1] == (3 or 4):
            img[i] = cv2.cvtColor(img[i], cv2.COLOR_BGR2GRAY)
            
        img[i] = cv2.medianBlur(img[i],5) # smooth the image so no false circles detected        
        circle_info = cv2.HoughCircles(img[i],cv2.HOUGH_GRADIENT,1,20,
                            param1=50,param2=30,minRadius=min_radius,maxRadius=max_radius)

        if  circle_info == None:
            print i
            print 'Error, no circles found!'
            return None
        elif circle_info.shape[-1] != 3: # for checking
            print 'Error, more than one circle found!'
            print i
            print circle_info
            return None
        circles[i,:]  = circle_info     
              
    x = np.mean(circles[:,0])
    y = np.mean(circles[:,1])
    r = np.mean(circles[:,2])
    return (x, y, r)
    
def bright_spot(img, ROI=[150,300,150,250], last = False): # if last is true, it is useful and checked as well 
    N = img.shape[0]    
    if last == False:    
        N = N-1
    top, bottom, left, right = ROI
    bright_spot_array = np.empty(shape=(N,2))
    
    # threshold the border of the image so brightest part is the spot not the phone 
    img2 = img.copy()
    img2[:,top:bottom,left:right] = 0
    img = img - img2
    
    for i in range(N):
        if img[i].shape[-1] == (3 or 4):
            img[i] = cv2.cvtColor(img[i], cv2.COLOR_BGR2GRAY)
        img[i] = cv2.GaussianBlur(img[i], (5,5), 0)
        bright_spot_array[i,:] = cv2.minMaxLoc(img[i])[3]
    return bright_spot_array
        
def masked_img(img,ROI,blur_radius=25,threshold=67):
    """input a single image and return a boolean array: true represents region of the object"""
    if img.shape[-1] == 3:
        img = img[:,:,-1]
        
    top,bottom,left,right = ROI    
    img2 = img.copy()
    img2[top:bottom,left:right] = 0
    img = img-img2
    img =  cv2.GaussianBlur(img, (blur_radius,blur_radius), 0) >  threshold 
    return img

def scale_image(img,white_board,background,last=False):
    if len(img.shape) == 3:
        N,height,width = img.shape
    elif len(img.shape) == 4:
        N,height,width,useless = img.shape
        img = img[:,:,:,2]
    else:
        print 'error! size of img array is not correct!'
        return None
    
    if last==False:
        N=N-1
        
    background_light = np.empty(shape=(N,height,width))
    if len(background.shape) == 2:
        background_light[:] = background
    elif len(background.shape) == 3:
        background_light[:] = background[:,:,2]
        
    background_light[:] = cv2.GaussianBlur(background_light[:], (3,3), 0)
                 
    if img.dtype == 'uint8':
        img.astype(float)
    background.astype(float)
    white_board.astype(float)
    
    
    print img.shape
    print background_light.shape
    print white_board.shape
    img = (img-background_light)/(white_board-background_light)
    
    n_nan,y_nan,x_nan = np.nonzero(np.isnan(img))
    for i in range(len(n_nan)):
        img[n_nan[i],y_nan[i],x_nan[i]] = 0
        
    n_inf,y_inf,x_inf = np.nonzero(img==float('inf'))
    for i in range(len(n_inf)):
        img[n_inf[i],y_inf[i],x_inf[i]] = 0

    return img

def light_direction(ball_array, ball_mask_array, ball_ROI, R, D, far=True, last=False):
    Xc, Yc, radius = ball_shape(ball_mask_array)
    bright_spot_array = bright_spot(ball_array, ball_ROI, last=last)   # whole ball_array is passed to the function. 'false' means the last one is not needed
    print bright_spot_array
    print Xc, Yc, radius
    D = D/(R/radius)
    
    if len(ball_array.shape) == 3: # image already in grayscale
        N, height, width = ball_array.shape
    else:
        N, height, width, useless = ball_array.shape        
    
    if last==False:
        N = N - 1
        
    bright_spot_normal = np.empty(shape=(N,3)) # for debugging   
    L_array = np.empty(shape=(N, height, width, 3))
    
    if far == False: # for correction at different points    
        x = np.arange(width)
        y = np.arange(height)
        index_map = np.meshgrid(x,y)
        
    for i in range(N):
        xo, yo = bright_spot_array[i]
        Nx = xo-Xc
        Ny = -(yo-Yc)
        Nz = np.sqrt(radius**2 - Nx**2 - Ny**2)
        n = np.array([Nx,Ny,Nz])/radius # surf normal vector at the bright spot
        print n
        L = 2*(n[2])*n - np.array([0,0,1])
        bright_spot_normal[i,:] = L
        
        # calculate the corrected L vector at different points if it is not 'far'
        if far == False:
            L_array[i,:,:,0] = D*(L[0]/L[2])-(index_map[0]-xo)
            L_array[i,:,:,1] = D*(L[1]/L[2])+(index_map[1]-yo)
            L_array[i,:,:,2] = D       
        else:
            L_array[i,:,:,:] = L
        # normalize the vector 
        L_array[i] = L_array[i] / np.sqrt((L_array[i]**2).sum(axis=-1))[:,:,None]         
    # L and L_array are all defined as the vector pointing from the object to the camera                
    return L_array, bright_spot_normal, D


def stacked_lstsq(L, b, rcond=1e-8):
    """
    Solve L x = b, via SVD least squares cutting of small singular values
    L is an array of shape (..., M, N) and b of shape (..., M).
    Returns x of shape (..., N)
    """
    u, s, v = np.linalg.svd(L, full_matrices=False)
    s_max = s.max(axis=-1, keepdims=True)
    s_min = rcond*s_max
    inv_s = np.zeros_like(s)
    inv_s[s >= s_min] = 1/s[s>=s_min]
    x = np.einsum('...ji,...j->...i', v,
                  inv_s * np.einsum('...ji,...j->...i', u, b.conj()))
    return np.conj(x, x)


def surf_normal_test(img_array, img_mask, white_board, light_direction ,last=False, blur=1):
    """this funcion calculates the surf normal of the object assuming 
    that the 'far' condition is satisfied. L is Nx3 array of light direction.
    img_array sssumes the images are already in grayscale/single colour channel.
    img_mask assumes the mask is just a 2D boolean array.
    Light_direcion is an array storing the light direction at each point of each image
    """
    #light_direction = light_direction[:,0,0,:] # only need a single set of vectors
    
    N,height,width = img_array.shape
    total_pix = height*width
    img_mask.astype(float)
    img_array.astype(float)
    white_board.astype(float)

    if last==False:
        N = N-1
        img_array = img_array[0:-1]

    # smooth the image and calibrate the intensity
    if blur>0:
        img_array[:] = cv2.GaussianBlur(img_array[:], (blur,blur), 0)
    img_array = img_array*img_mask

    """### check colour range of the thresholded image, used just for checking. it doesn't affect image
    for n in range(N):
        for row in range(height):
            for col in range(width):
                pix_count[img_array[n,row,col]]+=1"""
       
    img_array = img_array.reshape(N,total_pix)
    
    L = np.empty(shape=(total_pix,N,3))
    b = np.empty(shape=(total_pix,N))
    
    for i in range(N):
        b[:,i] = img_array[i]
    
    #print light_direction.shape
    #print total_pix,height,width,N
    #print total_pix
    light_direction = light_direction.reshape(N,total_pix,3) #checking
    #light_direction = light_direction.reshape(N,total_pix,3) #checking
    light_direction = np.rollaxis(light_direction,1) #checking
    L[:] = light_direction
    
    """
    start_time1 = time.time()
    b_median = np.median(b,axis=1)
    if N>=5:
        for pix in range(total_pix):
            for n in range(N):
                if b[pix,n] < 0.3*b_median[pix]:
                    b[pix,n] = 0
                    L[pix,n,:] = 0
                    shadow_map[pix,n] = 1
    elif N==4:
        b_min = np.argmin(b,axis=1)
        for pix in range(total_pix):
            if b[pix,b_min[pix]] < 0.5*b_median[pix]:
                b[pix,b_min[pix]] = 0
                L[pix,b_min[pix],:] = 0
                shadow_map[pix,b_min[pix]] = 1
    print time.time() - start_time1"""
    
            
    surf_normal_map = stacked_lstsq(L,b).reshape(height,width,3)
    surf_normal_map = surf_normal_map/np.sqrt((surf_normal_map**2).sum(axis=-1))[:,:,None]
    return surf_normal_map
        

def surf_height(surf_normal,penalty):
    
    def D_matrix(size):
        D_mat = np.zeros(shape=(size,size))
    
        D_mat[0,0] = -3
        D_mat[0,1] = 4
        D_mat[0,2] = -1
        D_mat[-1,-3] = 1
        D_mat[-1,-2] = -4
        D_mat[-1,3] = 3

        for row in range(1,size-1):
            D_mat[row,row-1] = -1
            D_mat[row,row+1] = 1
    
        D_mat = D_mat/2
        return D_mat
    
    def circle_estimate(height,width):
        if width % 2 == 0:
            x = np.arange(-int(width)/2,int(width)/2)
        else:
            x = np.arange(-int(width)/2+1,int(width)/2+1)
        if height % 2 == 0:
            y = np.arange(-int(height)/2,int(height)/2)
        else:
            y = np.arange(-int(height)/2+1,int(height)/2+1)            
        radius = min(height,width)/2
        X,Y = np.meshgrid(x,y)
        guess = np.sqrt(radius**2-X**2-Y**2)
        guess[np.isnan(guess)]=0
        height,width = guess.shape
        guess = guess + 10*(np.random.rand(height,width)-0.5)       
        guess[:,:] = 0        
        return guess
   
    normal_array[np.isnan(normal_array)]=0
    y,x = np.nonzero(surf_normal[:,:,0])
    left = np.min(x)
    right = np.max(x)
    top = np.min(y)
    bottom = np.max(y)
    surf_normal = surf_normal[top:bottom+1,left:right+1,:]
    #return surf_normal
    
    Zx = -surf_normal[:,:,0]
    Zy = surf_normal[:,:,1]

    height,width,useless = surf_normal.shape
    print height,width
    guess = circle_estimate(height,width)    
    Dy = D_matrix(height)
    Dx = D_matrix(width)
    
    A = np.dot(Dy.T,Dy) + penalty**2*np.identity(height)
    B = np.dot(Dx.T,Dx) + penalty**2*np.identity(width)
    Q = np.dot(Dy.T,Zy )+ np.dot(Zx,Dx)+2*penalty**2*guess
    
    Z = spl.solve_sylvester(A,B,Q)
    
    min_height = np.min(Z)
    Z = Z - min_height 
    
    Z = Z/masked_image[top:bottom+1,left:right+1]
    Z[Z==float('inf')] = np.nan
    Z[Z==(-float('inf'))] = np.nan

    return Z
    #return Z*masked_image[top:bottom+1,left:right+1]


### main program starts here ###
start_time = time.time()

 
path = "C:/Users/user/Documents/IC School Work/Summer Project/image processing code/code for actual setup/15-6-Mon"

ball_array = load_files(path,'*img_03*')
ball_mask_array = load_files(path,'*img_04*')
obj = load_files(path,'*img_05*',colour=True) #sphere
obj2 = load_files(path,'*img_06*',colour=True) # Einstein's head
obj3 = load_files(path,'*img_07*',colour=True) # green toy (flat)
obj4 = load_files(path,'*img_08*',colour=True)  # green toy (thin)
obj5 = load_files(path,'*img_09*',colour=True)  # Mark's hand
#obj6 = load_files(path,'*img_11*',colour=True)[4:]  # Dillon's hand
#obj7 = load_files(path,'*img_12*',colour=True)[4:]  # irregular object
board = load_files(path,'*img_02*',colour=True)[:-2,:,:,2]
board2 = load_files(path,'*img_01*',colour=True)[:-2,:,:,2]

   


board_avg = (board.astype(float)+board2.astype(float))/2

R = 5.0/2 # radius of the chrome ball in cm
D = 30.0 # distance from object to camera in cm
ball_ROI=[210,335,200,310] # region of interest for the ball mask


far_setting = True

L, bright_spot_normal, d = light_direction(ball_array[0:-2],ball_mask_array,ball_ROI,R,D,far=far_setting,last=True)


### white scattering ball as image
object_ROI = [170,335,185,350]
masked_image = masked_img(obj[-2],object_ROI)
background = obj[-1]
processed_image = scale_image(obj[0:-2],board_avg,background,last=True)
normal_array = surf_normal_test(processed_image,masked_image,board_avg,L,last=True,blur=1)
